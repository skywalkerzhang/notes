#### [96. 不同的二叉搜索树](https://leetcode-cn.com/problems/unique-binary-search-trees/)（理解dp数组）

题目：

给你一个整数 `n` ，求恰由 `n` 个节点组成且节点值从 `1` 到 `n` 互不相同的 **二叉搜索树** 有多少种？返回满足题意的二叉搜索树的种数。

 

样例：

```
输入：n = 3
输出：5
```



思路：

dp需要找重叠子问题，首先需要自己画一下n=1,n=2,n=3的搜索二叉树，可以发现**以1和3为根结点的树和n=2的情况一样，以2为根结点的树和n=1一样（这里的一样指的是数量）**

我们可以考虑构造得到不同的根结点构成的树。（这一步刚刚突然迷了下，其实就是构建f[]数组，不然数组里都没有值。突然脑抽。

令f[i]为n=i时二叉树的个数，即**1到i为节点组成的二叉搜索树的个数**。f[i] += f[以j为头结点左子树节点数量] * f[以j为头结点右子树节点数量]。**+= 是因为每个j的结果都要算上。**

根据搜索树的定义，如果结点j为他的左子树结点，其左子树的值为j-1（把视角转在j上，把j想成一个全新的树）**因为所有小于j的都是j的左子树，为j-1个。**

其右子树数量为i -j。**因为已知最大的数字是n（在分割遍历时是i），右子树上的结点值都应当> j，而>j个数为i -j**。

所以递推公式：f[i] += f[j - 1] * f[i - j]; ，j-1 为j为头结点左子树节点数量，i-j 为以j为头结点右子树节点数量。

初始化：f[0] = 1.初始化的值需要让代码能够顺利的累加，按理来说n=0时，不论0，1都有道理，但是因为需要更新数组，所以是1.另外，可以看到样例数据n >= 1	所以不用特判放心更新。

```java
class Solution {
    public int numTrees(int n) {
        int[] f = new int[n + 1];
        f[0] = 1;
        for(int i = 1; i <= n; i ++){
            for(int j = 1; j <= i; j ++){
                f[i] += f[j - 1] * f[i - j]; 
            }
        }
        return f[n];
    }
}
```





总结：非常好一道题，感觉又学到了很多，没思路的时候先画几个简单样例，题目求个数，而二叉树的结构本身就是相似的（指他自己和他的子树）。因此可以考虑记录下左子树右子树的个数，再利用搜索树的特性去得到左子树和右子树的个数。


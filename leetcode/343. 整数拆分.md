#### [343. 整数拆分](https://leetcode-cn.com/problems/integer-break/)

题目：

给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。

示例 1:

输入: 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1。
示例 2:

输入: 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。
说明: 你可以假设 n 不小于 2 且不大于 58。



思路：这个题我和卡哥想法也不太一样，我依然是使用了特判的方法，对于示例1而言，如果n = 2， 输出是1，但如果n = 3,可以发现2的乘积就是2了。

假设f[n]是n的最大乘积,那么f[n] = max(f[i] * f[n - i], f[n])。这时开始考虑初始化问题，毫无疑问f[1] = 1。但是f[2]呢？ 求f[3]时f[2] = 2,求f[2]时却是1.

这是由于**n必须拆分为至少两个正整数的和**。所以我的想法就是在循环里特判，如果我们更新的数组正好是n，那就不可以使用它本身作为乘积，而其他的数字是可以使用自身作为乘积的（**即计算f[n]时其自身可以视为最大乘积的候选人**）

故我的动态转移方程为（i代表要更新的数字，j代表拆分为两个数的其中一个）

```java
if(n == i) f[i] = Math.max(f[i - j] * f[j], f[i]);
else f[i] = Math.max(Math.max(f[i - j] * f[j], i), f[i]);
```


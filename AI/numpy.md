```python
num = 1
def fn():
    global num
    num += 1
    return lambda : print(num)
x = fn();
x() 
# 返回的是个函数
```

    2



```python
sets = {1, 2, 3, 4, 5}
# print(sets[2])
# set不可以用下标访问
```

numpy 100题

1. 导入numpy库并简写为 np
2. 打印numpy的版本和配置说明


```python
import numpy as np
print(np.__version__)
```

    1.21.2


3. 创建一个长度为10的空向量(0向量)


```python
x = np.zeros(10)
print(x)
```

    [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]


4. 如何找到任何一个数组的内存大小？
(提示: size, itemsize)


```python
print(x.size)
# 里面是元组
z = np.zeros((10, 10))
# z.size是数组的大小， z.itemsize是z的类型的大小
print(z.size, z.itemsize)
print("内存是", z.size * z.itemsize)
ch = np.char.add(['a','b'],['cd'])
print(ch.size, ch.itemsize)
```

    10
    100 8
    内存是 800
    2 12


5. 如何从命令行得到numpy中add函数的说明文档?


```python
np.info(np.add)
```

    add(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])
    
    Add arguments element-wise.
    
    Parameters
    ----------
    x1, x2 : array_like
        The arrays to be added.
        If ``x1.shape != x2.shape``, they must be broadcastable to a common
        shape (which becomes the shape of the output).
    out : ndarray, None, or tuple of ndarray and None, optional
        A location into which the result is stored. If provided, it must have
        a shape that the inputs broadcast to. If not provided or None,
        a freshly-allocated array is returned. A tuple (possible only as a
        keyword argument) must have length equal to the number of outputs.
    where : array_like, optional
        This condition is broadcast over the input. At locations where the
        condition is True, the `out` array will be set to the ufunc result.
        Elsewhere, the `out` array will retain its original value.
        Note that if an uninitialized `out` array is created via the default
        ``out=None``, locations within it where the condition is False will
        remain uninitialized.
    **kwargs
        For other keyword-only arguments, see the
        :ref:`ufunc docs <ufuncs.kwargs>`.
    
    Returns
    -------
    add : ndarray or scalar
        The sum of `x1` and `x2`, element-wise.
        This is a scalar if both `x1` and `x2` are scalars.
    
    Notes
    -----
    Equivalent to `x1` + `x2` in terms of array broadcasting.
    
    Examples
    --------
    >>> np.add(1.0, 4.0)
    5.0
    >>> x1 = np.arange(9.0).reshape((3, 3))
    >>> x2 = np.arange(3.0)
    >>> np.add(x1, x2)
    array([[  0.,   2.,   4.],
           [  3.,   5.,   7.],
           [  6.,   8.,  10.]])
    
    The ``+`` operator can be used as a shorthand for ``np.add`` on ndarrays.
    
    >>> x1 = np.arange(9.0).reshape((3, 3))
    >>> x2 = np.arange(3.0)
    >>> x1 + x2
    array([[ 0.,  2.,  4.],
           [ 3.,  5.,  7.],
           [ 6.,  8., 10.]])


6. 创建一个长度为10并且除了第五个值为1的空向量


```python
np.array([0, 0, 0, 0, 1, 0, 0, 0, 0, 0])
```




    array([0, 0, 0, 0, 1, 0, 0, 0, 0, 0])



7. 创建一个值域范围从10到49的向量


```python
x = np.arange(10, 50)
print(x)
```

    [10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33
     34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49]


8. 反转一个向量(第一个元素变为最后一个)


```python
x = x[::-1]
print(x)
```

    [49 48 47 46 45 44 43 42 41 40 39 38 37 36 35 34 33 32 31 30 29 28 27 26
     25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10]


9. 创建一个 3x3 并且值从0到8的矩阵


```python
z = np.arange(9).reshape(3, 3)
print(z)
```

    [[0 1 2]
     [3 4 5]
     [6 7 8]]


10. 找到数组[1,2,0,0,4,0]中非0元素的位置索引


```python
nz = np.nonzero([1,2,0,0,4,0])
print(nz)
```

    (array([0, 1, 4], dtype=int64),)


11. 创建一个 3x3 的单位矩阵（左上角到右下角为1，其他全为0）


```python
# eye是单位矩阵
x = np.eye(3)
print(x)
```

    [[1. 0. 0.]
     [0. 1. 0.]
     [0. 0. 1.]]


12. 创建一个 3x3x3的随机数组


```python
np.random.random((3,3,3))
```




    array([[[0.74605811, 0.37468636, 0.07968227],
            [0.20553907, 0.08679881, 0.73168834],
            [0.01467341, 0.1180034 , 0.1363029 ]],
    
           [[0.91535596, 0.89048469, 0.80081631],
            [0.41115856, 0.8016772 , 0.9597694 ],
            [0.35283524, 0.9113531 , 0.98269134]],
    
           [[0.17369227, 0.49913483, 0.09527206],
            [0.06959002, 0.16764076, 0.72791849],
            [0.51335894, 0.99986575, 0.48011724]]])



13. 创建一个 10x10 的随机数组并找到它的最大值和最小值


```python
x = np.random.random((10, 10))
print(x)
max_value = x.max()
min_value = x.min()
print(max_value, min_value)
```

    [[0.85644909 0.20050948 0.3865232  0.21114    0.1647392  0.36498253
      0.34424712 0.3741771  0.11823343 0.69915621]
     [0.87240344 0.57398639 0.27542715 0.08674377 0.3822319  0.611303
      0.09119418 0.7138369  0.61620027 0.78332071]
     [0.49430549 0.26607114 0.3430202  0.69536332 0.3016026  0.40558728
      0.07129383 0.50532439 0.98636062 0.54555883]
     [0.22884321 0.37346598 0.88264477 0.64696111 0.43715077 0.65793923
      0.18235436 0.51530095 0.87826766 0.99980818]
     [0.88351282 0.05782324 0.86867388 0.73329844 0.99219443 0.81113731
      0.30217914 0.23245664 0.0895568  0.16764686]
     [0.90389253 0.50777289 0.14785754 0.77054828 0.31304325 0.47333392
      0.44511406 0.37555627 0.12746302 0.33794839]
     [0.48778748 0.942405   0.8052614  0.24666672 0.81316381 0.12057841
      0.83707934 0.02803174 0.09119037 0.28133639]
     [0.79667337 0.43514215 0.49224613 0.94969691 0.40233917 0.12617965
      0.6636194  0.30417329 0.86073458 0.95699874]
     [0.63958657 0.93683821 0.16169967 0.62502416 0.44010436 0.2932238
      0.56057291 0.5024082  0.20107421 0.77176015]
     [0.30493023 0.53158177 0.31479491 0.50982633 0.72946198 0.02904947
      0.68554372 0.50958452 0.9090938  0.57225823]]
    0.999808184180839 0.028031743829679878


14. 创建一个长度为30的随机向量并找到它的平均值


```python
x = np.random.random(30)
avg = x.mean()
print(x, avg)
```

    [0.09616827 0.41872028 0.99776704 0.82293127 0.01481176 0.10318023
     0.49581719 0.49678583 0.78274204 0.80269702 0.0307729  0.65964531
     0.26522303 0.98061676 0.86489635 0.77477596 0.26991467 0.97765987
     0.04017733 0.63925175 0.83019433 0.00810503 0.73484866 0.7039365
     0.20655304 0.75519534 0.78150641 0.71465984 0.00818428 0.53441889] 0.5270719066682176


15.创建一二维数组，其中边界值为1，其余值为0


```python
z = np.ones((10, 10))
print(z)
# 1表示从第二个开始取，-1表示最后一个，但是最后一个取不到
z[1:-1, 1:-1] = 0
print(z)
```

    [[1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
     [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
     [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
     [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
     [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
     [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
     [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
     [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
     [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
     [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]]
    [[1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
     [1. 0. 0. 0. 0. 0. 0. 0. 0. 1.]
     [1. 0. 0. 0. 0. 0. 0. 0. 0. 1.]
     [1. 0. 0. 0. 0. 0. 0. 0. 0. 1.]
     [1. 0. 0. 0. 0. 0. 0. 0. 0. 1.]
     [1. 0. 0. 0. 0. 0. 0. 0. 0. 1.]
     [1. 0. 0. 0. 0. 0. 0. 0. 0. 1.]
     [1. 0. 0. 0. 0. 0. 0. 0. 0. 1.]
     [1. 0. 0. 0. 0. 0. 0. 0. 0. 1.]
     [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]]


16. 对于一个存在在数组，如何添加一个用0填充的边界?


```python
z = np.pad(z, pad_width=1, mode='constant', constant_values = 0)
print(z)
```

    [[0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
     [0. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 0.]
     [0. 1. 0. 0. 0. 0. 0. 0. 0. 0. 1. 0.]
     [0. 1. 0. 0. 0. 0. 0. 0. 0. 0. 1. 0.]
     [0. 1. 0. 0. 0. 0. 0. 0. 0. 0. 1. 0.]
     [0. 1. 0. 0. 0. 0. 0. 0. 0. 0. 1. 0.]
     [0. 1. 0. 0. 0. 0. 0. 0. 0. 0. 1. 0.]
     [0. 1. 0. 0. 0. 0. 0. 0. 0. 0. 1. 0.]
     [0. 1. 0. 0. 0. 0. 0. 0. 0. 0. 1. 0.]
     [0. 1. 0. 0. 0. 0. 0. 0. 0. 0. 1. 0.]
     [0. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 0.]
     [0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]]


17. 以下表达式运行的结果分别是什么?


```python
print(0*np.nan)

print(np.nan==np.nan)

print(np.inf>np.nan)

print(np.nan-np.nan)

print(round(0.3, 2)==round(3*0.1, 2))

print(np.inf > 0)
print(-np.inf < 0)
```

    nan
    False
    False
    nan
    True
    True
    True


nan(NAN，Nan):not a number 表示不是一个数字，np.nan是一个float类型的数据

因为nan不是一个数，所以相关计算都无法得到数字。

**所有涉及nan的操作，返回的都是nan**

inf,-inf和nan没法比较大小


<br/>
“0.1==0.3返回值是假,即0 因为在计算机中浮点数的表示是误差的。所以一般情况下不进行两个浮点数是否相同的比较。而是比较两个浮点数的差点绝对值,是否小于一个很小的正数。如果条件满足,就认为这两个浮点数是相同的。”

比浮点数大小可以考虑Decimal

18. 创建一个 5x5的矩阵，并设置值1,2,3,4落在其对角线下方位置（答案是y）


```python
x = np.diag(1 + np.arange(4))
print(x)
```

    [[1 0 0 0]
     [0 2 0 0]
     [0 0 3 0]
     [0 0 0 4]]



```python
y = np.diag(1 + np.arange(4), -1)
print(y)
```

    [[0 0 0 0 0]
     [1 0 0 0 0]
     [0 2 0 0 0]
     [0 0 3 0 0]
     [0 0 0 4 0]]



```python
z = np.diag(1 + np.arange(4), 1)
print(z)
```

    [[0 1 0 0 0]
     [0 0 2 0 0]
     [0 0 0 3 0]
     [0 0 0 0 4]
     [0 0 0 0 0]]


19. 创建一个8x8 的矩阵，并且设置成棋盘样式


```python
z = np.zeros((8, 8), dtype = int)
z[0::2, 1::2] = 1
z[1::2, 0::2] = 1
print(z)
```

    [[0 1 0 1 0 1 0 1]
     [1 0 1 0 1 0 1 0]
     [0 1 0 1 0 1 0 1]
     [1 0 1 0 1 0 1 0]
     [0 1 0 1 0 1 0 1]
     [1 0 1 0 1 0 1 0]
     [0 1 0 1 0 1 0 1]
     [1 0 1 0 1 0 1 0]]


20. 考虑一个 (6,7,8) 形状的数组，其第100个元素的索引(x,y,z)是什么?


```python
print(np.unravel_index(100,(6,7,8)))
```

    (1, 5, 4)


21. 用tile函数去创建一个 8x8的棋盘样式矩阵


```python
 z = np.tile( np.array([[0,1],[1,0]]), (4,4))
print(z)
```

    [[0 1 0 1 0 1 0 1]
     [1 0 1 0 1 0 1 0]
     [0 1 0 1 0 1 0 1]
     [1 0 1 0 1 0 1 0]
     [0 1 0 1 0 1 0 1]
     [1 0 1 0 1 0 1 0]
     [0 1 0 1 0 1 0 1]
     [1 0 1 0 1 0 1 0]]


22. 对一个5x5的随机矩阵做归一化


```python
z = np.random.random((5, 5))
print(z)
z_max, z_min = z.max(), z.min()
z = (z - z_min) / (z_max - z_min)
print(z)
```

    [[0.75977844 0.44305448 0.45058271 0.2168507  0.9717216 ]
     [0.99314752 0.90557787 0.00718293 0.9783395  0.47957789]
     [0.88673117 0.44653545 0.47695341 0.55684797 0.39061042]
     [0.13112151 0.37202691 0.32427834 0.77981954 0.91748518]
     [0.15708389 0.45764285 0.08897743 0.41594382 0.01370668]]
    [[0.76330887 0.44207628 0.44971167 0.21265244 0.97826908]
     [1.         0.91118377 0.         0.98498119 0.4791196 ]
     [0.89206879 0.4456068  0.47645776 0.55748963 0.38888566]
     [0.12570287 0.37003761 0.32160933 0.78363525 0.92326059]
     [0.15203483 0.45687231 0.08295886 0.41457968 0.00661662]]


23. 创建一个将颜色描述为(RGBA)四个无符号字节的自定义dtype？


```python
color = np.dtype([("r", np.ubyte, 1),
("g", np.ubyte, 1),
("b", np.ubyte, 1),
("a", np.ubyte, 1)])
color
```

    C:\Users\rina\AppData\Local\Temp/ipykernel_9104/2326290210.py:1: FutureWarning: Passing (type, 1) or '1type' as a synonym of type is deprecated; in a future version of numpy, it will be understood as (type, (1,)) / '(1,)type'.
      color = np.dtype([("r", np.ubyte, 1),





    dtype([('r', 'u1'), ('g', 'u1'), ('b', 'u1'), ('a', 'u1')])



24. 一个5x3的矩阵与一个3x2的矩阵相乘，实矩阵乘积是什么？


```python
x = np.random.random((5, 3))
y = np.random.random((3, 2))
x@y
```




    array([[1.32230307, 1.06269985],
           [1.54309585, 1.20505958],
           [1.21603001, 1.02966628],
           [1.09551827, 0.77248196],
           [1.70895694, 1.27085982]])



25. 给定一个一维数组，对其在3到8之间的所有元素取反


```python
np.random.seed(47)
z = np.random.random(15) * 10
z[(z >= 3) & (z <= 8)] *= -1
# & 和 and的区别
# z[(z >= 3) & (z <= 8)] *= -1
z
```




    array([ 1.13488472,  9.74483094, -7.28734634, -3.51467806, -7.07605138,
           -7.99604602, -6.45561855, -4.14599607, -7.06031011,  2.46649382,
            2.55992431,  0.24011354,  0.98725955, -3.00436435, -6.40855678])



26. 下面脚本运行后的结果是什么?


```python
print(np.sum(range(5),-1))
```

    10


### 关于轴 https://blog.csdn.net/qq_33254870/article/details/82940243

27. 考虑一个整数向量Z,下列表达合法的是哪个?


Z**Z 合法

2<\<Z>\>2 不合法

Z<-Z 合法

1j*Z 合法

Z/1/1 合法

Z\<Z\>Z 不合法

28. 下列表达式的结果分别是什么?


```python
print(np.array(0) /np.array(0))

print(np.array(0) //np.array(0))

print(np.array([np.nan]).astype(int).astype(float))
```

    nan
    0
    [-2.14748365e+09]


    C:\Users\rina\AppData\Local\Temp/ipykernel_9104/3456651611.py:1: RuntimeWarning: invalid value encountered in true_divide
      print(np.array(0) /np.array(0))
    C:\Users\rina\AppData\Local\Temp/ipykernel_9104/3456651611.py:3: RuntimeWarning: divide by zero encountered in floor_divide
      print(np.array(0) //np.array(0))


29. 如何从零位对浮点数组做舍入 ?


```python
z = np.random.uniform(-10,+10,10)
print(z)
# 四舍五入
print(np.round(z))
# ？标答 看不懂
# 好像是小数只要有就会入进去……？
print(np.copysign(np.ceil(np.abs(z)), z))
```

    [ 8.00626032  8.3411175  -5.66232961 -1.98757511  0.90344314  2.83844381
     -0.52738971  1.27148251  1.78567308 -3.72823353]
    [ 8.  8. -6. -2.  1.  3. -1.  1.  2. -4.]
    [ 9.  9. -6. -2.  1.  3. -1.  2.  2. -4.]


30. 如何找到两个数组中的共同元素? (交集)


```python
z1 = np.random.randint(0,10,10)
z2 = np.random.randint(0,10,10)
print(z1, z2)
print(np.intersect1d(z1,z2))
```

    [7 5 5 6 5 0 9 7 9 4] [2 5 3 1 4 6 2 2 4 9]
    [4 5 6 9]


31. 如何忽略所有的 numpy 警告(尽管不建议这么做)?


```python
defaults = np.seterr(all="ignore")
z = np.ones(1) / 0
```

恢复


```python
_=np.seterr(**defaults)
z = np.ones(1) / 0
```

32. 下面的表达式是正确的吗?

np.sqrt(-1) == np.emath.sqrt(-1) false

33. 如何得到昨天，今天，明天的日期?


```python
yesterday = np.datetime64('today', 'D') - np.timedelta64(1, 'D')
today = np.datetime64('today', 'D')
tomorrow = np.datetime64('today', 'D') + np.timedelta64(1, 'D')
print ("Yesterday is " + str(yesterday))
print ("Today is " + str(today))
print ("Tomorrow is "+ str(tomorrow))
```

    Yesterday is 2022-01-25
    Today is 2022-01-26
    Tomorrow is 2022-01-27


34. 如何得到所有与2016年7月对应的日期？


```python
Z = np.arange('2016-07', '2016-08', dtype='datetime64[D]')
print(Z)
```

    ['2016-07-01' '2016-07-02' '2016-07-03' '2016-07-04' '2016-07-05'
     '2016-07-06' '2016-07-07' '2016-07-08' '2016-07-09' '2016-07-10'
     '2016-07-11' '2016-07-12' '2016-07-13' '2016-07-14' '2016-07-15'
     '2016-07-16' '2016-07-17' '2016-07-18' '2016-07-19' '2016-07-20'
     '2016-07-21' '2016-07-22' '2016-07-23' '2016-07-24' '2016-07-25'
     '2016-07-26' '2016-07-27' '2016-07-28' '2016-07-29' '2016-07-30'
     '2016-07-31']


35. 如何直接在位计算(A+B)\*(-A/2)(不建立副本)? 【看不懂】


```python
A = np.ones(3)*1
B = np.ones(3)*2
C = np.ones(3)*3
np.add(A,B,out=B)
np.divide(A,2,out=A)
np.negative(A,out=A)
np.multiply(A,B,out=A)
```




    array([-1.5, -1.5, -1.5])



36. 用五种不同的方法去提取一个随机数组的整数部分


```python
np.random.seed(47)
z = np.random.random(1)
z = np.float64(0.0)
print(z)
print (z - z % 1)
print (np.floor(z))
print (np.ceil(z)-1)
print (z.astype(int))
print (np.trunc(z))
```

    0.0
    0.0
    0.0
    -1.0
    0
    0.0


37. 创建一个5x5的矩阵，其中每行的数值范围从0到4


```python
z = np.zeros((5, 5))
# 广播机制
z += np.arange(0, 5)
z
```




    array([[0., 1., 2., 3., 4.],
           [0., 1., 2., 3., 4.],
           [0., 1., 2., 3., 4.],
           [0., 1., 2., 3., 4.],
           [0., 1., 2., 3., 4.]])



38. 通过考虑一个可生成10个整数的函数，来构建一个数组


```python
def generate():
    for x in range(10):
        yield x
Z = np.fromiter(generate(),dtype=float,count=-1)
print (Z)
```

    [0. 1. 2. 3. 4. 5. 6. 7. 8. 9.]


简单地讲，yield 的作用就是把一个函数变成一个 generator，带有 yield 的函数不再是一个普通函数，Python 解释器会将其视为一个 generator，调用 fab(5) 不会执行 fab 函数，而是返回一个 iterable 对象！在 for 循环执行时，每次循环都会执行 fab 函数内部的代码，执行到 yield b 时，fab 函数就返回一个迭代值，下次迭代时，代码从 yield b 的下一条语句继续执行，而函数的本地变量看起来和上次中断执行前是完全一样的，于是函数继续执行，直到再次遇到 yield。

39. 创建一个长度为10的随机向量，其值域范围从0到1，但是不包括0和1


```python
# linspace 左闭右闭
z = np.linspace(0, 1, 11)
print(z)
# endpoint = False 不加终点
z = np.linspace(0, 1, 11, endpoint = False)[1:]
np.random.shuffle(z)
print(z)
```

    [0.  0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1. ]
    [0.45454545 0.27272727 0.18181818 0.54545455 0.63636364 0.90909091
     0.36363636 0.09090909 0.81818182 0.72727273]


40. 创建一个长度为10的随机向量，并将其排序


```python
z = np.random.random(10)
print(z)
z = np.sort(z)
print(z)
```

    [0.91719355 0.2709208  0.27354789 0.95441268 0.12711457 0.74726485
     0.00523796 0.85679061 0.6959562  0.5530257 ]
    [0.00523796 0.12711457 0.2709208  0.27354789 0.5530257  0.6959562
     0.74726485 0.85679061 0.91719355 0.95441268]


41.对于一个小数组，如何用比 np.sum更快的方式对其求和？


```python
Z = np.arange(10)
np.add.reduce(Z)
```




    45



42. 对于两个随机数组A和B，检查它们是否相等


```python
A = np.random.randint(0,2,5)
B = np.random.randint(0,2,5)
# Assuming identical shape of the arrays and a tolerance for the comparison of values
equal = np.allclose(A,B)
print(equal)
```

    False



```python
# Checking both the shape and the element values, no tolerance (values have to be exactly equal)
equal = np.array_equal(A,B)
print(equal)
```

    False


43. 创建一个只读数组(read-only)


```python
Z = np.zeros(10)
Z.flags.writeable = False
```

44. 将笛卡尔坐标下的一个10x2的矩阵转换为极坐标形式


```python
Z = np.random.random((10,2))
X, Y = Z[:, 0], Z[:, 1]
R = np.sqrt(X ** 2 + Y ** 2)
T = np.arctan2(Y, X)
print (R)
print (T)
```

    [0.61789918 0.5773605  0.3954876  0.85781115 0.68845435 0.95593293
     1.17857536 0.96085466 0.58313483 1.1694091 ]
    [1.30941465 1.39015512 0.21589502 0.8564087  0.27846561 0.0617847
     0.72750012 1.30491122 0.70333551 0.70078272]


45. 创建一个长度为10的向量，并将向量中最大值替换为1


```python
z = np.random.random(10)
print(z)
idx = z.argmax()
print(idx)
z[idx] = 1
z
```

    [0.83529596 0.08537584 0.48829082 0.90031302 0.91705588 0.21688352
     0.40062124 0.54517216 0.64192219 0.47363051]
    4





    array([0.83529596, 0.08537584, 0.48829082, 0.90031302, 1.        ,
           0.21688352, 0.40062124, 0.54517216, 0.64192219, 0.47363051])



46. 创建一个结构化数组，并实现 x 和 y 坐标覆盖 [0,1]x[0,1] 区域


```python
Z = np.zeros((5,5), [('x',float),('y',float)])
Z['x'], Z['y'] = np.meshgrid(np.linspace(0,1,5),
np.linspace(0,1,5))
print(Z)
```

    [[(0.  , 0.  ) (0.25, 0.  ) (0.5 , 0.  ) (0.75, 0.  ) (1.  , 0.  )]
     [(0.  , 0.25) (0.25, 0.25) (0.5 , 0.25) (0.75, 0.25) (1.  , 0.25)]
     [(0.  , 0.5 ) (0.25, 0.5 ) (0.5 , 0.5 ) (0.75, 0.5 ) (1.  , 0.5 )]
     [(0.  , 0.75) (0.25, 0.75) (0.5 , 0.75) (0.75, 0.75) (1.  , 0.75)]
     [(0.  , 1.  ) (0.25, 1.  ) (0.5 , 1.  ) (0.75, 1.  ) (1.  , 1.  )]]


结构化数据类型可以被认为是一定长度的字节序列（结构的项目大小），它被解释为字段集合。每个字段在结构中都有一个名称，一个数据类型和一个字节偏移量。字段的数据类型可以是包括其他结构化数据类型的任何numpy数据类型，也可以是子行数据类型，其行为类似于指定形状的ndarray。字段的偏移是任意的，字段甚至可以重叠。这些偏移量通常由numpy自动确定，但也可以指定

47. 给定两个数组X和Y，构造Cauchy矩阵C (Cij =1/(xi - yj)) 【柯西矩阵】 【答案我觉得有问题】


```python
X = np.arange(8)
Y = X + 0.5
print(X, Y)
```

    [0 1 2 3 4 5 6 7] [0.5 1.5 2.5 3.5 4.5 5.5 6.5 7.5]



```python
# np.substract.outer将给出b中的每个值与a中的其他值之间的差值，
C = 1.0 / np.subtract.outer(X, Y)
# np.linalg.det():矩阵求行列式
print(np.linalg.det(C))
```

    3638.163637117973



```python
# 上面是标答，我不理解
C = np.zeros((X.size, Y.size))
for i in range(8):
    for j in range(8):
        C[i, j] = 1.0 / (X[i] - Y[j])
        
print(C)
```

    [[-2.         -0.66666667 -0.4        -0.28571429 -0.22222222 -0.18181818
      -0.15384615 -0.13333333]
     [ 2.         -2.         -0.66666667 -0.4        -0.28571429 -0.22222222
      -0.18181818 -0.15384615]
     [ 0.66666667  2.         -2.         -0.66666667 -0.4        -0.28571429
      -0.22222222 -0.18181818]
     [ 0.4         0.66666667  2.         -2.         -0.66666667 -0.4
      -0.28571429 -0.22222222]
     [ 0.28571429  0.4         0.66666667  2.         -2.         -0.66666667
      -0.4        -0.28571429]
     [ 0.22222222  0.28571429  0.4         0.66666667  2.         -2.
      -0.66666667 -0.4       ]
     [ 0.18181818  0.22222222  0.28571429  0.4         0.66666667  2.
      -2.         -0.66666667]
     [ 0.15384615  0.18181818  0.22222222  0.28571429  0.4         0.66666667
       2.         -2.        ]]


48. 打印每个numpy标量类型的最小值和最大值？


```python
for dtype in [np.int8, np.int32, np.int64]:
    print(dtype, "min: ", np.iinfo(dtype).min)
    print(dtype, "max: ", np.iinfo(dtype).max)
for dtype in [np.float32, np.float64]:
    print(dtype, "min: ", np.finfo(dtype).min)
    print(dtype, "max: ", np.finfo(dtype).max)
    print(dtype, "eps: ", np.finfo(dtype).eps)
```

    <class 'numpy.int8'> min:  -128
    <class 'numpy.int8'> max:  127
    <class 'numpy.int32'> min:  -2147483648
    <class 'numpy.int32'> max:  2147483647
    <class 'numpy.int64'> min:  -9223372036854775808
    <class 'numpy.int64'> max:  9223372036854775807
    <class 'numpy.float32'> min:  -3.4028235e+38
    <class 'numpy.float32'> max:  3.4028235e+38
    <class 'numpy.float32'> eps:  1.1920929e-07
    <class 'numpy.float64'> min:  -1.7976931348623157e+308
    <class 'numpy.float64'> max:  1.7976931348623157e+308
    <class 'numpy.float64'> eps:  2.220446049250313e-16


49. 如何打印一个数组中的所有数值?

(标答错的)


```python
np.set_printoptions(threshold = np.nan)
Z = np.zeros((16,16))
print(Z)
# 数值的潜台词就是，nan不打印，他是not a number
```


    ---------------------------------------------------------------------------
    
    ValueError                                Traceback (most recent call last)
    
    ~\AppData\Local\Temp/ipykernel_9104/4068318520.py in <module>
    ----> 1 np.set_printoptions(threshold = np.nan)
          2 Z = np.zeros((16,16))
          3 print(Z)
          4 # 数值的潜台词就是，nan不打印，他是not a number


    ~\AppData\Local\Programs\Python\Python39\lib\site-packages\numpy\core\arrayprint.py in set_printoptions(precision, threshold, edgeitems, linewidth, suppress, nanstr, infstr, formatter, sign, floatmode, legacy)
        250 
        251     """
    --> 252     opt = _make_options_dict(precision, threshold, edgeitems, linewidth,
        253                              suppress, nanstr, infstr, sign, formatter,
        254                              floatmode, legacy)


    ~\AppData\Local\Programs\Python\Python39\lib\site-packages\numpy\core\arrayprint.py in _make_options_dict(precision, threshold, edgeitems, linewidth, suppress, nanstr, infstr, sign, formatter, floatmode, legacy)
         86             raise TypeError("threshold must be numeric")
         87         if np.isnan(threshold):
    ---> 88             raise ValueError("threshold must be non-NAN, try "
         89                              "sys.maxsize for untruncated representation")
         90 


    ValueError: threshold must be non-NAN, try sys.maxsize for untruncated representation


如果想用set_printoptions要像下面这么用，杜绝很大的值，但是显然，这道题就不该这么做


```python
import sys
np.set_printoptions(threshold = sys.maxsize)
```

应该选出nan不要了，但是二维信息也没了，就是不理解他要啥


```python
Z = np.zeros((16,16))
Z[2, 2] = np.nan
print(Z)
print(Z[~np.isnan(Z)])
```

    [[ 0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.]
     [ 0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.]
     [ 0.  0. nan  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.]
     [ 0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.]
     [ 0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.]
     [ 0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.]
     [ 0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.]
     [ 0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.]
     [ 0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.]
     [ 0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.]
     [ 0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.]
     [ 0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.]
     [ 0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.]
     [ 0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.]
     [ 0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.]
     [ 0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.]]
    [0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.
     0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.
     0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.
     0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.
     0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.
     0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.
     0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.
     0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.
     0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.
     0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.
     0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]


50. 给定标量时，如何找到数组中最接近标量的值？


```python
Z = np.arange(100)
v = np.random.uniform(0,100)
# 计算绝对值最小的下标，就是最接近的数字
print(Z)
print(v)
index = (np.abs(Z-v)).argmin()
print (Z[index])
```

    [ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23
     24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47
     48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71
     72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95
     96 97 98 99]
    58.928365409537854
    59


51. 创建一个表示位置(x,y)和颜色(r,g,b)的结构化数组


```python
Z = np.zeros(10, [ ('position', [ ('x', float, 1),
('y', float, 1)]),
('color', [ ('r', float, 1),
('g', float, 1),
('b', float, 1)])])
print (Z)
```

    [((0., 0.), (0., 0., 0.)) ((0., 0.), (0., 0., 0.))
     ((0., 0.), (0., 0., 0.)) ((0., 0.), (0., 0., 0.))
     ((0., 0.), (0., 0., 0.)) ((0., 0.), (0., 0., 0.))
     ((0., 0.), (0., 0., 0.)) ((0., 0.), (0., 0., 0.))
     ((0., 0.), (0., 0., 0.)) ((0., 0.), (0., 0., 0.))]


    C:\Users\rina\AppData\Local\Temp/ipykernel_9104/2687674408.py:1: FutureWarning: Passing (type, 1) or '1type' as a synonym of type is deprecated; in a future version of numpy, it will be understood as (type, (1,)) / '(1,)type'.
      Z = np.zeros(10, [ ('position', [ ('x', float, 1),


52. 对一个表示坐标形状为(10,2)的随机向量，找到点与点的距离


```python
Positions = np.random.random((10, 2))
# numpy.atleast_2d(*arys)
# 将输入视为至少具有二维的数组。
X, Y = np.atleast_2d(Positions[:, 0], Positions[:, 1])
# print(X, Y)

# 求距离就是x和x的差， y和y的差。这里应该使用转置
# 因为使用了广播机制，是每行都减同一个数字，每列也是
# 矩阵维度从（10,1）和(1,10)变成了(10, 10)
D = np.sqrt((X - X.T) ** 2 + (Y - Y.T) ** 2)
print (D)
```

    [[0.         0.59977185 0.96032974 0.16622814 0.12791335 0.27475042
      0.65891782 0.90968135 0.80448362 0.87887636]
     [0.59977185 0.         0.42125478 0.57371488 0.52583725 0.67171576
      0.15229462 0.43323019 0.45007665 0.47964818]
     [0.96032974 0.42125478 0.         0.8796368  0.8559334  0.93409986
      0.30572226 0.12704467 0.30345808 0.24822706]
     [0.16622814 0.57371488 0.8796368  0.         0.07066361 0.13096669
      0.59411064 0.81132411 0.68440846 0.7631784 ]
     [0.12791335 0.52583725 0.8559334  0.07066361 0.         0.20162283
      0.56161096 0.79655883 0.68243244 0.75855012]
     [0.27475042 0.67171576 0.93409986 0.13096669 0.20162283 0.
      0.66824919 0.85143215 0.70470096 0.78633091]
     [0.65891782 0.15229462 0.30572226 0.59411064 0.56161096 0.66824919
      0.         0.29024662 0.29961459 0.32752013]
     [0.90968135 0.43323019 0.12704467 0.81132411 0.79655883 0.85143215
      0.29024662 0.         0.18114324 0.12120151]
     [0.80448362 0.45007665 0.30345808 0.68440846 0.68243244 0.70470096
      0.29961459 0.18114324 0.         0.08213459]
     [0.87887636 0.47964818 0.24822706 0.7631784  0.75855012 0.78633091
      0.32752013 0.12120151 0.08213459 0.        ]]



```python
# 用scipy
import scipy.spatial
D = scipy.spatial.distance.cdist(Positions, Positions)
print(D)
```

    [[0.         0.59977185 0.96032974 0.16622814 0.12791335 0.27475042
      0.65891782 0.90968135 0.80448362 0.87887636]
     [0.59977185 0.         0.42125478 0.57371488 0.52583725 0.67171576
      0.15229462 0.43323019 0.45007665 0.47964818]
     [0.96032974 0.42125478 0.         0.8796368  0.8559334  0.93409986
      0.30572226 0.12704467 0.30345808 0.24822706]
     [0.16622814 0.57371488 0.8796368  0.         0.07066361 0.13096669
      0.59411064 0.81132411 0.68440846 0.7631784 ]
     [0.12791335 0.52583725 0.8559334  0.07066361 0.         0.20162283
      0.56161096 0.79655883 0.68243244 0.75855012]
     [0.27475042 0.67171576 0.93409986 0.13096669 0.20162283 0.
      0.66824919 0.85143215 0.70470096 0.78633091]
     [0.65891782 0.15229462 0.30572226 0.59411064 0.56161096 0.66824919
      0.         0.29024662 0.29961459 0.32752013]
     [0.90968135 0.43323019 0.12704467 0.81132411 0.79655883 0.85143215
      0.29024662 0.         0.18114324 0.12120151]
     [0.80448362 0.45007665 0.30345808 0.68440846 0.68243244 0.70470096
      0.29961459 0.18114324 0.         0.08213459]
     [0.87887636 0.47964818 0.24822706 0.7631784  0.75855012 0.78633091
      0.32752013 0.12120151 0.08213459 0.        ]]


53. 如何将32位的浮点数(float)转换为对应的整数(integer)?


```python
Z = np.arange(10, dtype=np.float32)
Z = Z.astype(np.int32, copy=False)
print (Z)
```

    [0 1 2 3 4 5 6 7 8 9]


54. 如何读取以下文件?


```python
from io import StringIO
import numpy as np
s = StringIO("1, 2, 3, 4, 5, 6, , , 7, 8, , 9,10,11")
data = np.genfromtxt(s, dtype=np.int32, delimiter=",")
data
```




    array([ 1,  2,  3,  4,  5,  6, -1, -1,  7,  8, -1,  9, 10, 11])



55. 对于numpy数组，enumerate的等价操作是什么？


```python
Z = np.arange(9).reshape(3,3)
for index, value in np.ndenumerate(Z):
    print (index, value)
for index in np.ndindex(Z.shape):
    print (index, Z[index])
```

    (0, 0) 0
    (0, 1) 1
    (0, 2) 2
    (1, 0) 3
    (1, 1) 4
    (1, 2) 5
    (2, 0) 6
    (2, 1) 7
    (2, 2) 8
    (0, 0) 0
    (0, 1) 1
    (0, 2) 2
    (1, 0) 3
    (1, 1) 4
    (1, 2) 5
    (2, 0) 6
    (2, 1) 7
    (2, 2) 8


56.生成一个通用的二维Gaussian-like数组

【按照公式算的】


```python
# 自动生成X, Y
X, Y = np.meshgrid(np.linspace(-1, 1, 10), np.linspace(-1, 1, 10))
# print(X, Y)
D = np.sqrt(X * X + Y * Y)
sigma, mu = 1.0, 0.0
G = np.exp(-( (D - mu)**2 / ( 2.0 * sigma ** 2 ) ) )
print (G)
```

    [[0.36787944 0.44822088 0.51979489 0.57375342 0.60279818 0.60279818
      0.57375342 0.51979489 0.44822088 0.36787944]
     [0.44822088 0.54610814 0.63331324 0.69905581 0.73444367 0.73444367
      0.69905581 0.63331324 0.54610814 0.44822088]
     [0.51979489 0.63331324 0.73444367 0.81068432 0.85172308 0.85172308
      0.81068432 0.73444367 0.63331324 0.51979489]
     [0.57375342 0.69905581 0.81068432 0.89483932 0.9401382  0.9401382
      0.89483932 0.81068432 0.69905581 0.57375342]
     [0.60279818 0.73444367 0.85172308 0.9401382  0.98773022 0.98773022
      0.9401382  0.85172308 0.73444367 0.60279818]
     [0.60279818 0.73444367 0.85172308 0.9401382  0.98773022 0.98773022
      0.9401382  0.85172308 0.73444367 0.60279818]
     [0.57375342 0.69905581 0.81068432 0.89483932 0.9401382  0.9401382
      0.89483932 0.81068432 0.69905581 0.57375342]
     [0.51979489 0.63331324 0.73444367 0.81068432 0.85172308 0.85172308
      0.81068432 0.73444367 0.63331324 0.51979489]
     [0.44822088 0.54610814 0.63331324 0.69905581 0.73444367 0.73444367
      0.69905581 0.63331324 0.54610814 0.44822088]
     [0.36787944 0.44822088 0.51979489 0.57375342 0.60279818 0.60279818
      0.57375342 0.51979489 0.44822088 0.36787944]]


57. 对一个二维数组，如何在其内部随机放置p个元素?


```python
n = 10
p = 3
Z = np.zeros((n,n))
'''
def choice(a, size=None, replace=True, p=None)
    表示从a中随机选取size个数
    replacement 代表的意思是抽样之后还放不放回去，如果是False的话，那么通一次挑选出来的数都不一样，如果是True的话， 有可能会出现重复的，因为前面的抽的放回去了。
    p表示每个元素被抽取的概率，如果没有指定，a中所有元素被选取的概率是相等的。
'''
# 随机取数，然后再赋值回去
np.put(Z, np.random.choice(range(n*n), p, replace=False),1)
print (Z)
```

    [[0. 0. 0. 0. 0. 0. 0. 0. 1. 0.]
     [0. 0. 0. 0. 1. 0. 1. 0. 0. 0.]
     [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
     [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
     [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
     [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
     [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
     [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
     [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
     [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]]


58. 减去一个矩阵中的每一行的平均值`


```python
x = np.random.random((5,5))
x -= x.mean(axis = 1, keepdims = True)
# or
# x -= x.mean(axis = 1).reshape(-1, 1)
x
```




    array([[ 0.17246149,  0.26584417, -0.34863161, -0.26525138,  0.17557733],
           [-0.45882215,  0.10809244, -0.30922578,  0.48087732,  0.17907817],
           [ 0.03961591, -0.01171511, -0.14828089, -0.04334763,  0.16372771],
           [-0.11049839,  0.01106936, -0.05355143,  0.1737148 , -0.02073434],
           [-0.04501061, -0.0974183 ,  0.27879942,  0.00468548, -0.14105598]])



59. 如何通过第n列对一个数组进行排序?


```python
Z = np.random.randint(0,10,(3,3))
print(Z)
print(Z[Z[:,1].argsort()])
```

    [[4 5 3]
     [6 1 2]
     [6 4 5]]
    [[6 1 2]
     [6 4 5]
     [4 5 3]]



```python

```

## RTTI & 反射

Java的类型信息有两种方式，一种是编译的时候就知道类型的RTTI，另一种是反射信息，在运行时发现和使用类的信息

* 为什么需要RTTI，是因为我们希望java在运行的时候可以尽量少的知道具体类型，只与这个类的家族通用表示打交道。代码更容易写、读和维护。

  **多态（动态绑定）是面向对象编程的基本目标**

* Class对象：用于实施RTTI，每个类都有Class对象，文件编译时会产生一个Class对象，也就是.class文件。所有的类都是在对其第一次使用时动态的加载在JVM系统中的。程序创造第一个静态成员引用的时候，会加载这个类，证明构造器是静态的类方法。Java程序在运行前并没有被完全加载，而是在必须使用时才会加载。首先类加载器会判断类是否加载，如果没有加载，就会根据类名去寻找.class文件，然后在类的字节码加载时对其验证以保证其没有被损坏，并且不包含不良代码。当一个类被载入内存，他就用来创造该类的所有对象。

* Class.forName(String) 返回的是一个Class对象的引用，用这句话可以先加载类。

* object.getClass()来获得已知object的引用

* 可以用.class来获取Class的引用，并不会自动初始化class对象。一般类的准备有三步：1. 加载：由类加载器进行，先执行字节码并且创建一个class对象。 2.链接：将验证类的字节码，为静态资源分配空间，必要的话解析这个类创建对其他类的所有引用。3.初始化：如果该类有超类，就执行超类的初始化，执行初始化器和初始化块。

  如果使用.class的话，初始化被延迟到了对静态方法或者非常数静态域的首次引用时才执行（比如调用static final int时不需要初始化）。

* a instanceof B: a 是B的实例

* a.isInstance(B) a是B的实例

* 对于类的比较 instanceof 和 isInstance 一样，指a是B这个类或者这个类的派生类；== 和equals也一样，不考虑继承，仅判断是不是这个类

  

* 反射：在运行时打开.class文件，有Field, Method和Constructor类